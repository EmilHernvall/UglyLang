options {
    STATIC = false ;
    UNICODE_INPUT = true ;
}

PARSER_BEGIN(Parser)
package se.c0la.uglylang;

import java.util.*;

import se.c0la.uglylang.ast.*;
import se.c0la.uglylang.type.*;

public class Parser
{
    private Map<String, Type> types = null;
}
PARSER_END(Parser)

SKIP :
{
  "/*" : WithinComment
}
<WithinComment> SKIP :
{
  "*/" : DEFAULT
}
<WithinComment> MORE :
{
  <~[]>
}

TOKEN : { < #ident : ("-")? <nmstart> (<nmchar>)* > }
TOKEN : { < #name : (<nmchar>)+ > }
TOKEN : { < #nmstart : ["a"-"z","A"-"Z"] | "_" | <nonascii> | <escape> > }
TOKEN : { < #nonascii : ["\u0080"-"\uD7FF","\uE000"-"\uFFFD"] > }
TOKEN : { < #unicode : "\\" (["a"-"f","A"-"F","0"-"9"]){1,6} (<wc>)? > }
TOKEN : { < #escape : <unicode> | "\\" ["\u0020"-"\u007E","\u0080"-"\uD7FF","\uE000"-"\uFFFD"] > }
TOKEN : { < #nmchar : ["a"-"z","A"-"Z","0"-"9"] | "_" | <nonascii> | <escape> > }
TOKEN : { < #num : (["0"-"9"])+ | (["0"-"9"])* "." (["0"-"9"])+ > }
TOKEN : { < #string : "\"" (<stringchar> | "'")* "\"" | "'" (<urlchar> | "\"")* "'" > }
TOKEN : { < #stringchar : <urlchar> | "\u0020" | "\\" <nl> > }
TOKEN : { < #urlchar : ["\u0009","\u0021","\u0023"-"\u0026","\u0028"-"\u007E"] | <nonascii> | <escape> > }
TOKEN : { < #nl : "\n" | "\r" "\n" | "\r" | "\u000C" > }
TOKEN : { < #wc: "\u0009" | "\n" | "\u000C" | "\r" | "\u0020" > }
TOKEN : { < #w : (<wc>)* > }

TOKEN : { < SUBSCRIPT : "." > }
TOKEN : { < AND : "and" > }
TOKEN : { < OR : "or" > }
TOKEN : { < NOT : "not" > }
TOKEN : { < XOR : "xor" > }
TOKEN : { < IFSTMT : "if" > }
TOKEN : { < RETURNSTMT : "return" > }
TOKEN : { < EQ : "==" > }
TOKEN : { < NOTEQ : "!=" > }
TOKEN : { < GT : ">" > }
TOKEN : { < GTEQ : ">=" > }
TOKEN : { < LT : "<" > }
TOKEN : { < LTEQ : "<=" > }
TOKEN : { < ASSIGN : "=" > }
TOKEN : { < ADD : "+" > }
TOKEN : { < SUB : "-" > }
TOKEN : { < MUL : "*" > }
TOKEN : { < DIV : "/" > }
TOKEN : { < MOD : "%" > }
TOKEN : { < EXP : "^" > }
TOKEN : { < LPAR : "(" > }
TOKEN : { < RPAR : ")" > }
TOKEN : { < LCLAUSE : "{" > }
TOKEN : { < RCLAUSE : "}" > }
TOKEN : { < LBRACKET : "[" > }
TOKEN : { < RBRACKET : "]" > }
TOKEN : { < STMTBREAK : ";" > }
TOKEN : { < LISTSEP : "," > }
TOKEN : { < IDENT : <ident> > }
TOKEN : { < STRING : <string> > }
TOKEN : { < NUMBER : <num> > }
TOKEN : { < S : (<wc>)+ > }

/*
 * rule for whitespace:
 * a rule consumes all the trailing whitespace, but no
 * whitespace ahead.
 */

List<Node> parse() :
{
    Token t ;
    Node n ;
    List<Node> nodes ;
}
{
    {
        nodes = new ArrayList<Node>();

        types = new HashMap<String, Type>();
        types.put("int", new IntegerType());
        types.put("string", new StringType());
        types.put("bool", new BooleanType());
        types.put("void", new VoidType());
    }
    (<S>)*
    (
        n = Statement()
        { nodes.add(n); }
    )*

    { return nodes; }
}

Type FunctionType() :
{
    Type type, type2 ;
    List<Type> params ;
}
{
    { params = new ArrayList<Type>(); }
    <LPAR>
    type = Type()
    <RPAR>
    <LPAR>
    [
        type2 = Type()
        { params.add(type2); }
        (
            ","
            (<S>)*
            type2 = Type()
            { params.add(type2); }
        )*
    ]
    <RPAR>
    { type = new FunctionType(type, params); }

    { return type; }
}

Type TupleType() :
{
    Type type, type2 ;
    List<Type> params ;
}
{
    { params = new ArrayList<Type>(); }
    <LPAR>
    [
        type2 = Type()
        { params.add(type2); }
        (
            ","
            (<S>)*
            type2 = Type()
            { params.add(type2); }
        )*
    ]
    <RPAR>
    { type = new TupleType(params); }

    { return type; }
}

Type NamedTupleType() :
{
    Token t ;
    Type type, type2 ;
    Map<String, Type> params ;
}
{
    { params = new LinkedHashMap<String, Type>(); }
    <LPAR>
    [
        t = <IDENT>
        ":"
        (<S>)*
        type2 = Type()
        { params.put(t.image, type2); }
        (
            ","
            (<S>)*
            t = <IDENT>
            ":"
            (<S>)*
            type2 = Type()
            { params.put(t.image, type2); }
        )*
    ]
    <RPAR>
    { type = new NamedTupleType(params); }

    { return type; }
}

Type Type() :
{
    Token t ;
    Type type, type2 ;
    List<Type> params ;
}
{
    (
        LOOKAHEAD ( FunctionType() )
        type = FunctionType()
        |
        LOOKAHEAD ( TupleType() )
        type = TupleType()
        |
        LOOKAHEAD ( NamedTupleType() )
        type = NamedTupleType()
        |
        (
            t = <IDENT>
            {
                type = types.get(t.image);
                if (type == null) {
                    throw new ParseException("Type " + t.image + " not found.");
                }
            }
        )
    )
    (
        <LBRACKET>
        <RBRACKET>
        { type = new ArrayType(type); }
    )*
    (<S>)*

    { return type; }
}

Node Statement() :
{
    Token t ;
    Node n, n2 ;
    Expression expr, expr2 ;
    Declaration d ;
}
{
    (
        LOOKAHEAD( <IFSTMT> )
            n = IfStatement()
        |
        LOOKAHEAD( <RETURNSTMT> )
            <RETURNSTMT>
            (<S>)+
            expr = Expression()
            <STMTBREAK>
            (<S>)*
            { n = new ReturnStatement(expr); }
        |
        LOOKAHEAD( <IDENT> (<S>)* <ASSIGN>)
            t = <IDENT>
            (<S>)*
            { expr = new Variable(t.image, true); }
            <ASSIGN>
            (<S>)*
            expr2 = Expression()
            { n = new AssignNode(expr, expr2); }
            <STMTBREAK>
            (<S>)*
        |
        LOOKAHEAD( <IDENT> <SUBSCRIPT> <IDENT> (<S>)* <ASSIGN> )
            t = <IDENT>
            { expr = new Variable(t.image, false); }
            <SUBSCRIPT>
            t = <IDENT>
            (<S>)*
            <ASSIGN>
            (<S>)*
            expr2 = Expression()
            { n = new AssignSubscriptNode(expr, t.image, expr2); }
            <STMTBREAK>
            (<S>)*
        |
        LOOKAHEAD( Declaration() <ASSIGN> )
            d = Declaration()
            <ASSIGN>
            (<S>)*
            expr = Expression()
            { n = new AssignDeclarationNode(d, expr); }
            <STMTBREAK>
            (<S>)*
        |
            n = Expression()
            <STMTBREAK>
            (<S>)*
    )

    { return n; }
}

Node IfStatement() :
{
    Token t ;
    Node n, n2 ;
    List<Node> stmts;
}
{
    { stmts = new ArrayList<Node>(); }
    <IFSTMT>
    (<S>)*
    n = Expression()
    <LCLAUSE>
    (<S>)*
    (
        n2 = Statement()
        { stmts.add(n2); }
    )*
    <RCLAUSE>
    (<S>)*

     { return new IfStatement(n, stmts); }
}

Declaration Declaration() :
{
    Token t ;
    Type type ;
    String name ;
    Node value ;
    Declaration d ;
}
{
    type = Type()
    t = <IDENT>
    { name = t.image; }
    { d = new Declaration(type, name); }
    (<S>)*

    { return d; }
}

TupleNode Tuple() :
{
    List<Expression> nodes ;
    Expression n ;
}
{
    { nodes = new ArrayList<Expression>(); }
    <LPAR>
    (<S>)*
    (
        n = Expression()
        { nodes.add(n); }
        ","
        (<S>)*
    )+
    <RPAR>
    (<S>)*

    { return new TupleNode(nodes); }
}

NamedTupleNode NamedTuple() :
{
    Map<String, Expression> nodes ;
    Token t ;
    Expression n ;
}
{
    { nodes = new LinkedHashMap<String, Expression>(); }
    <LPAR>
    (<S>)*
    t = <IDENT>
    ":"
    (<S>)*
    n = Expression()
    { nodes.put(t.image, n); }
    (
        ","
        (<S>)*
        t = <IDENT>
        ":"
        (<S>)*
        n = Expression()
        { nodes.put(t.image, n); }
    )*
    <RPAR>
    (<S>)*

    { return new NamedTupleNode(nodes); }
}

ArrayNode Array() :
{
    List<Expression> nodes ;
    Expression n ;
}
{
    { nodes = new ArrayList<Expression>(); }
    <LBRACKET>
    (<S>)*
    n = Expression()
    { nodes.add(n); }
    (
        ","
        (<S>)*
        n = Expression()
        { nodes.add(n); }
    )*
    <RBRACKET>
    (<S>)*

    { return new ArrayNode(nodes); }
}

FunctionDecl Function() :
{
    Token t ;
    Type type ;
    Node n ;
    Declaration d ;
    FunctionDecl f ;
    List<Declaration> params ;
    List<Node> statements ;
}
{
    { params = new ArrayList<Declaration>(); }
    { statements = new ArrayList<Node>(); }
    <LPAR>
    type = Type()
    <RPAR>
    <LPAR>
    [
        d = Declaration()
        { params.add(d); }
        (
            ","
            (<S>)*
            d = Declaration()
            { params.add(d); }
        )*
    ]
    <RPAR>
    (<S>)*
    <LCLAUSE>
        (<S>)*
        (
            n = Statement()
            { statements.add(n); }
        )*
    <RCLAUSE>
    (<S>)*

    { return new FunctionDecl(type, params, statements); }
}

Expression Expression() :
{
    Token t ;
    Expression n, n2 ;
}
{
    n = Expression2()
    (
            <AND>
            (<S>)*
            n2 = Expression2()
            { n = new AndNode(n, n2); }
        |
            <OR>
            (<S>)*
            n2 = Expression2()
            { n = new OrNode(n, n2); }
        |
            <XOR>
            (<S>)*
            n2 = Expression2()
            { n = new XorNode(n, n2); }
    )*

    { return n; }
}

Expression Expression2() :
{
    Token t ;
    Expression n, n2 ;
}
{
    n = Expression3()
    (
            <EQ>
            (<S>)*
            n2 = Expression3()
            { n = new EqualNode(n, n2); }
        |
            <NOTEQ>
            (<S>)*
            n2 = Expression3()
            { n = new NotEqualNode(n, n2); }
        |
            <LT>
            (<S>)*
            n2 = Expression3()
            { n = new LtNode(n, n2); }
        |
            <GT>
            (<S>)*
            n2 = Expression3()
            { n = new GtNode(n, n2); }
        |
            <LTEQ>
            (<S>)*
            n2 = Expression3()
            { n = new LtEqNode(n, n2); }
        |
            <GTEQ>
            (<S>)*
            n2 = Expression3()
            { n = new GtEqNode(n, n2); }
    )*

    { return n; }
}

Expression Expression3() :
{
    Token t ;
    Expression n, n2 ;
}
{
    (
        n = Expression4()
        (
                <ADD>
                (<S>)*
                n2 = Expression4()
                { n = new AddNode(n, n2); }
            |
                <SUB>
                (<S>)*
                n2 = Expression4()
                { n = new SubNode(n, n2); }
        )*
    )

    { return n; }
}

Expression Expression4() :
{
    Token t ;
    Expression n, n2 ;
}
{
    (
        n = Expression5()
        (
                <MUL>
                (<S>)*
                n2 = Expression5()
                { n = new MulNode(n, n2); }
            |
                <DIV>
                (<S>)*
                n2 = Expression5()
                { n = new DivNode(n, n2); }
            |
                <MOD>
                (<S>)*
                n2 = Expression5()
                { n = new ModNode(n, n2); }
        )*
    )

    { return n; }
}

Expression Expression5() :
{
    Token t, t2 ;
    Expression n, n2 ;
    List<Expression> params ;
}
{
    (
        LOOKAHEAD( Function() )
            n = Function()
        |
        /*LOOKAHEAD( Tuple() )
            n = Tuple()
        |*/
        LOOKAHEAD( NamedTuple() )
            n = NamedTuple()
        |
        LOOKAHEAD( Array() )
            n = Array()
        |
            <LPAR>
            (<S>)*
            n = Expression()
            <RPAR>
            (<S>)*
        |
            t = <IDENT>
            (<S>)*
            { n = new Variable(t.image, false); }
        |
            t = <NUMBER>
            (<S>)*
            { n = new IntegerConstant(t.image); }
        |
            t = <STRING>
            (<S>)*
            { n = new StringConstant(t.image.substring(1, t.image.length()-1)); }
    )

    [
        <SUBSCRIPT>
        t = <IDENT>
        (<S>)*
        { n = new SubscriptNode(n, t.image, false); }
    ]

    [
        <LBRACKET>
        n2 = Expression()
        <RBRACKET>
        (<S>)*
        { n = new IndexNode(n, n2, false); }
    ]

    [
        <LPAR>
        (<S>)*
        { params = new ArrayList<Expression>(); }

        [
            n2 = Expression()
            { params.add(n2); }
            (
                <LISTSEP>
                (<S>)*
                n2 = Expression()
                { params.add(n2); }
            )*
        ]
        <RPAR>
        (<S>)*
        { n = new FunctionCall(n, params); }
    ]

    { return n; }
}
